"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("./cli");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const logger = __importStar(require("./logger"));
const lockfile = __importStar(require("@yarnpkg/lockfile"));
const factory = __importStar(require("./factory"));
const utils_1 = require("./utils");
const reporter_1 = require("./reporter");
const validator_1 = require("./validator");
const findPackageJson_1 = require("./findPackageJson");
const { npmToYarn } = require('synp');
exports.getParsedValue = (lockfilePath) => {
    if (lockfilePath.match("package-lock.json")) {
        const stringifiedYarnLock = npmToYarn(path.dirname(lockfilePath));
        return lockfile.parse(stringifiedYarnLock);
    }
    const raw = fs.readFileSync(lockfilePath, "utf8");
    return lockfile.parse(raw);
};
exports.generateCategorizedData = (obj, found, testPattern = undefined, warningPattern = undefined, testSkipPattern = undefined) => {
    const isWarningTarget = (name) => !!warningPattern && !!name.match(warningPattern);
    const isErrorTarget = (name) => !!testPattern && !!name.match(testPattern);
    const isTarget = (name) => isWarningTarget(name) || isErrorTarget(name) || false;
    const isIgnore = (name) => !!testSkipPattern && !!name.match(testSkipPattern);
    const { installedPackage } = factory.generatePackageStructure({ type: "yarn", data: obj }, found, isTarget, isIgnore);
    const categorizedData = {
        errors: [],
        warning: [],
    };
    Object.entries(installedPackage).forEach(([packageName, value]) => {
        // TODO exclude "|| {}""
        if (Object.keys(value || {}).length > 1) {
            const valueObject = value || {};
            const realInstalledVersions = utils_1.uniq(Object.values(valueObject).map(d => d.realUsedVersion));
            const isCheckTarget = !!testPattern && !!packageName.match(testPattern);
            // 実際に利用しているバージョンが異なるものを複数もつ場合 かつ、チェック対象の場合
            if (realInstalledVersions.length > 1 && isErrorTarget(packageName)) {
                categorizedData.errors.push({
                    name: packageName,
                    dependencies: Object.values(valueObject),
                });
            }
            else if (realInstalledVersions.length > 1 && isWarningTarget(packageName)) {
                categorizedData.warning.push({
                    name: packageName,
                    dependencies: Object.values(valueObject),
                });
            }
        }
    });
    return categorizedData;
};
const main = async () => {
    const params = cli_1.getInputParams();
    const parsedValue = exports.getParsedValue(params.inputLockFile);
    const found = findPackageJson_1.findPackageJson(path.dirname(params.inputLockFile));
    const categorizedData = exports.generateCategorizedData(parsedValue.object, found, params.testPattern ? new RegExp(params.testPattern) : undefined, params.warningPattern ? new RegExp(params.warningPattern) : undefined, params.ignorePattern ? new RegExp(params.ignorePattern) : undefined);
    if (params.jsonFileName) {
        fs.mkdirSync(path.dirname(params.jsonFileName), { recursive: true });
        fs.writeFileSync(params.jsonFileName, JSON.stringify(categorizedData, null, 2));
        logger.info("");
        logger.info(`Generate JSON File: ${params.jsonFileName}`);
        logger.info("");
    }
    if (params.html) {
        const reportHtml = reporter_1.generateReport(categorizedData);
        fs.writeFileSync(params.html, reportHtml);
        logger.info("");
        logger.info(`Generate HTML: ${params.html}`);
        logger.info("");
    }
    if (!params.jsonFileName && !params.html) {
        validator_1.validate(categorizedData);
    }
};
main()
    .then(() => {
    process.exit(0);
})
    .catch(error => {
    console.error(error);
    process.exit(1);
});
